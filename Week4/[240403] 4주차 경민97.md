# [240403] 4주차

# 창발성

### 창발적 설계로 깔끔한 코드를 구현하자

다음 규칙을 따르는 설계는 ‘단순하다’. (중요도 순)

- 모든 테스트 실행
- 중복 제거
- 프로그래머 의도 표현
- 클래스와 메서드 수 최소

### 단순한 설계 규칙 1: 모든 테스트 실행

- 테스트 불가능한 시스템은 검증도 불가능하다. 그러한 시스템은 출시해선 안된다.
- 테스트 가능한 시스템을 만들기 위한 노력은 설계 품질을 높인다.
- SRP를 준수하는 작은 클래스가 많아지고, 테스트 코드 작성이 쉬워진다.
- ‘테스트 케이스 만들고 실행’ → 낮은 결합도 / 높은 응집력 → 객체지향적 높은 품질

### 단순한 설계 규칙 2~4: 리팩터링

- 테스트 케이스 작성 완료 → 코드와 클래스 정리
- 코드를 정리하며 시스템이 깨질까 걱정할 필요가 없다!
- 설계 품질을 높이는 기법이라면 무엇이든 적용

### 중복을 없애라

- 중복 = 추가 작업, 추가 위험, 불필요한 복잡도
- 구현 중복도 중복의 한 형태다

```jsx
// 중복
int size() {..}
boolean isEmpty() {...}

// 개선
boolean isEmpty() { return size() == 0; }
```

- 중복 로직 메서드 추출 → SRP 위반 감지 → 메서드 분리 → 메서드 가시성 증가 → 재사용성 증가
- Template Method Pattern 은 고차원 중복을 제거할 목적으로 자주 사용

### 표현하라

- 소프트웨어 비용 중 대부분은 장기적인 유지보수에 사용
- 좋은 이름 선택, 함수와 클래스는 작게, 표준 명칭 사용, 꼼꼼한 단위 케이스 작성

### 클래스와 메서드 수를 최소로 줄여라

- 무작정 줄이면 실이 많다. ‘가능한’ 줄인다.
- 우선순위가 높지는 않다. **테스트케이스,중복제거, 의도표현**이 더 중요

# 동시성

### 동시성이 필요한 이유

- ‘무엇(what)과 언제(when)’의 결합을 분리하는 전략
스레드가 하나인 경우 밀접하다.
- 분리 시 애플리케이션 구조와 효율이 극적으로 나아진다.
- 동시성과 관련된 오해
    - 항상 성능을 높여준다? 
    → ‘때로’ 성능을 높여준다. 대기 시간이 아주 길어 여러 스레드가 프로세스를 공유하거나, 여러 프로세서가 동시에 처리할 독립적 계산이 많은 경우.
    - 설계는 변하지 않는다? 
    → 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
    - 웹 또는 EJB 컨테이너 사용하면 동시성 이해할 필요 없다? 
    → 실제 동작 원리, 동시 수정, 데드락 문제 등을 알아야 한다.
- 동시성과 관련된 타당한 생각
    - 다소 부하를 유발한다. 
    → 성능 측면 + 코드량 증가
    - 복잡하다. 
    → 간단한 문제라도 복잡해질 수 있다.
    - 버그는 재현하기 어렵다. 
    → 결함이 아닌 일회성이라고 무시되기 쉽다.
    - 근본적인 설계 전략을 재고해야 한다.

### 난관

- 여러 스레드가 같은 변수를 동시에 참조하면 잘못된 결과가 발생
- 두 스레드가 특정 메서드를 실행하는 경우의 수는 수만, 수백만 가지가 될 수 있음.

### 동시성 방어 원칙

- 단일 책임 원칙
    - 동시성 관련 코드를 다른 코드와 분리한다.
    - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
    - 잠재적인 많은 문제 상황과 실패 케이스가 있다.
- 따름 정리: 자료 범위 제한
    - 임계 영역(critical section)을 synchronized 키워드로 보호
    - 임계 영역 수를 줄이는 기술이 중요하다.
    - 자료를 캡슐화 하고 공유 자료를 최대한 줄여라.
- 따름 정리: 사본 사용
    - 처음부터 공유하지 않는 방법이 제일 좋다. 읽기 전용 사본
- 따름 정리: 독립적 스레드 구현
    - 다른 스레드와 자료를 공유하지 않고, 요청 하나를 처리하는 스레드 구현

### 라이브러리를 이해하라

- 스레드 환경에 안전한 컬렉션
    - HashMap → ConcurrentHashMap
    - ReentrantLock, Semaphore, CountDownLatch
    - java.util.{concurrent, atomic, locks}

### 실행 모델을 이해하라

기본 용어 정리

| 한정된 자원
(Bound Resource) | 다중 스레드 환경에서 사용하는 자원. 크기나 숫자가 제한적이다.
(예) DB 커넥션, 유한 길이 버퍼 |
| --- | --- |
| 상호 배제
(Mutual Exclusion) | 한 번에 한 스레드만 공유 자원 사용 |
| 기아 (Starvation) | 스레드가 거의 영원히 자원을 기다린다. |
| 데드락 (Deadlock) | 여러 스레드가 서로 끝나기를 기다린다.
점유 하고 뺏기지 않아 어느쪽도 더 이상 진행하지 못한다. |
| 라이브락(Livelock) | 락을 거는 단계에서 스레드가 서로를 방해한다. 공명 현상으로 영원히 진행하지 못한다. |
- 생산자-소비자
    - 한정된 대기열을 잘못 구현할 경우, 진행 가능함에도 서로에게 시그널을 기다린다.
    - 생산자: 빈 공간을 기다림. 소비자: 대기열 데이터를 기다림
- 읽기-쓰기
    - 읽기가 메인, 쓰기가 서브일 경우 처리율이 핵심
    - 처리율을 높이려다가 기아 현상 또는 오래된 정보 쌓임
    - 읽기 스레드가 계속 점유한다면 쓰기 스레드는 기아 상태
    - 쓰기 스레드가 계속 이어진다면 처리율 감소
- 식사하는 철학자들
    - 여러 프로세스가 자원을 얻으려 경쟁. 누구는 내려놓아야 가능

### 동기화하는 메서드들 사이에 존재하는 존재하는 의존성을 이해하라

- 동기화 메서드 사이 의존성 존재 시 찾아내기 어려운 버그 발생
- 공유 클래스 하나에 synchronized 메서드 여럿일 경우(되도록 하나여야 함) 구현 올바른지 검증 필요
- 필요하다면 다음 셋 중 하나
    - 클라이언트에서 첫 메서드 호출 전 서버 잠금
    - 서버에서 잠금
    - 잠금을 수행하는 중간 단계

### 동기화하는 부분을 작게 만들어라

- synchronized 남발할 경우 스레드를 지연시키고 부하 가중
- 최소한의 작은 임계 영역을 생성하라

### 올바른 종료 코드는 구현하기 어렵다

- 스레드가 절대 오지 않을 시그널을 기다리는 ‘데드락’ 문제 흔함
    - 부모 스레드가 자식 스레드를 종료해야 하는데, 자식 스레드 하나가 데드락에 빠질 경우
    - 자식스레드 두 개가 생산자/소비자 관계라면 하나가 종료돼도 메시지를 기다림 → 부모로 전파
    - 종료 코드를 개발 초기부터 고민하고 신중히 구현. 생각보다 어려우므로 이미 존재하는 알고리즘 검토

### 스레드 코드 테스트하기

충분한 테스트는 위험을 낮춘다. 문제를 노출하는 테스트를 작성하고, 설정과 부하를 바꿔가며 자주 실행

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
    - 시스템 실패를 ‘일회성’으로 치부하지 마라
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
    - 스레드 환경과 환경 밖 코드를 동시에 디버깅하지 마라. 환경 밖부터 먼저
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 구현
    - 다양한 설정으로 실행하기 쉽게 구현하라
    - 스레드 개수를 하나, 여럿, 실행 중에 변경하며, 환경을 바꿔보고, 테스트 코드 속도 변경
- 다중 스레드를 쓰는 코드를 상황에 맞게 조율할 수 있도록 작성
    - 상당한 시행착오가 필요하다. 스레드 개수 조율 쉽게 구현하라
    - 처리율과 효울에 따라 스스로 스레드 개수를 조율하는 코드도 고민
- 프로세서 수보다 많은 스레드를 돌려보라
    - 스레드 스와핑 시에도 문제 발생
    - 잦을수록 임계영역 누락 또는 데드락 발생 코드 탐지 쉬움
- 다른 플랫폼에서 돌려보라
    - 운영체제마다 스레드 처리 정책이 달라질 수 있다.
- 코드에 보조 코드(instrument)를 넣어 돌려라 (강제 실패)
    - Object.wait(), sleep(), yield() priority() 등을 이용, 다양한 순서로 실행한다.
    - 잘못된 코드라면 가능한 자주 실행하는 편이 좋다.
    - 직접 구현하기
    - 코드에 직접 함수 추가
        - 문제: 보조코드를 어디에, 어디서? 성능감소, 무작위적
        - POJO와 스레드 코드 분리
    - 자동화
        - AOF, CGLIB, ASM과 같은 보조 도구 사용
        - 좋은 테스트 케이스와 jiggle 기법은 오류 탐지 확률을 높여준다.

### 결론

- 다중 스레드 코드는 올바로 구현하기 어렵다.
- 무엇보다 SRP를 준수한다.
- 잠정적인 원인을 철저히 이해한다.
- 기본 라이브러리와 알고리즘을 이해한다.
- 임계 영역 발견, 코드 잠금 기법을 이해한다.
- 어디서는 문제는 생기므로 많은 설정으로 반복 테스트한다.
- 시간을 들여 보조 코드를 추가한다.
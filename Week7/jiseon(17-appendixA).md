# 7주차 정리
## 17장. 냄새와 휴리스틱

### 자바

**J1: 긴 import 목록을 피하고 와일드카드를 사용하라**

- 패키지에 클래스를 둘 이상 사용한다면 와일드 카드를 사용해 패키지 전체를 가져온다.
- 명시적으로 클래스까지 import하면 강한 의존성을 생성하지만 와일드카드는 그렇지 않다.
- 때때로 이름 충돌이나 모호성을 초래한다. 하지만 명시적으로 import문을 사용해야 하는 경우는 자주 발생하지 않으므로 와일드 카드문을 사용한다.

**J2: 상수는 상속하지 않는다**

- 상수를 상속 계층 맨 위에 숨겨놓는 건 아주 끔찍한 관행이다. 상속을 이렇게 사용하는 건 언어의 범위 규칙을 속이는 행위다.

→ 대신 static import를 사용해라

**J3: 상수 대 Enum** 

- public static final int라는 옛날 기교를 더 이상 사용할 필요가 없다.
- int는 코드에서 의미를 잃어버리기도 한다. 반면 enum은 그렇지 않다. enum은 이름이 부여된 열거체에 속하기때문이다.
- enum은 메서드와 필드도 사용할 수 있다.

### 이름

**N1: 서술적인 이름을 사용하라**

- 이름은 성급하게 정하지 않는다. 서술적인 이름을 신중하게 고른다.
- 소프트웨어가 진화하면 의미도 변하므로 선택한 이름이 적합한지 자주 되돌아본다.
- 소프트웨어 가독성의 90%는 이름이 결정한다. 충분한 시간을 들여 현명한 이름을 선택하고 유효한 상태로 유지한다.
- 신중하게 선택한 이름은 추가 설명을 포함한 코드보다 강력하다.

**N2: 적절한 추상화 수준에서 이름을 선택하라**

- 구현을 드러내는 이름을 피하라.
- 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라.
- 인간은 추상화 수준을 뒤섞는 능력이 뛰어나 쉽지 않은 작업이다.
- 발견할 때마다 기회를 잡아 바꿔놓아야 한다.
- 안정적인 코드를 만들려면 지속적인 개선과 노력이 필요하다.

**N3: 가능하다면 표준 명명법을 사용하라**

- 기존 명명법을 사용하는 이름은 이해하기 더 쉽다.
    - e.g. DECORATOR 패턴을 활용한다면 장식하는 클래스 이름에 Decorator라는 단어를 사용해야 한다.
    - e.g. 자바에서 객체를 문자열로 변환하는 함수는 toString이라는 이름을 많이 쓴다.
- 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.

**N4: 명확한 이름**

- 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.

**N5: 긴 범위는 긴 이름을 사용하라**

- 이름 길이는 범위 길이에 비레해야 한다.
- 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 하지만 범위가 길어지면 긴 이름을 사용한다.
- 범위가 5줄 안팎이라면 i나 j와 같은 변수 이름도 괜찮다. 반면 이름이 짧은 변수나 함수는 범위가 길어지면 의미를 잃는다. 그러므로 범위가 길수록 이름을 정확하고 길게 짓는다.

**N6: 인코딩을 피하라**

- 이름에 유형 정보나 범위 정보를 넣어서는 안 된다.
- 오늘날 개발 환경에서는 이름 앞에 m_이나 f와 같은 접두어가 불필요하다.

**N7: 이름으로 부수 효과를 설명하라**

- 함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용한다.
- 이름에 부수 효과를 숨기지 않는다.

### 테스트

**T1: 불충분한 테스트**

- 테스트는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.
- 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.

**T2: 커버리지 도구를 사용하라!**

- 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다.
- 테스트가 불충분한 모듈, 클래스, 함수를 찾기 쉬워진다.

**T3: 사소한 테스트를 건너뛰지 마라**

- 사소한 테스트는 짜기 쉽다. 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다.

**T4: 무시한 테스트는 모호함을 뜻한다.**

- 때로는 요구사항이 불분명하기에 프로그램이 돌아가는 방식을 확신하기 어렵다.
- 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다.
- 선택 기준은 모호함이 존재하는 테스트 케이스가 컴파일이 가능한지 불가능한지에 달렸다.

**T5: 경계 조건을 테스트하라**

- 경계 조건은 각별히 신경 써서 테스트한다.
- 알고리즘의 중앙 조건은 올바로 짜놓고 경계 조건에서 실수하는 경우가 흔하다.

**T6: 버그 주변은 철저히 테스트하라**

- 버그는 서로 모이는 경향이 있다.
- 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다. 십중팔구 다른 버그도 발견하리라.

**T7: 실패 패턴을 살펴라**

- 때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.
- 합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.

**T8: 테스트 커버리지 패턴을 살펴라**

- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.

**T9: 테스트는 빨라야 한다.**

- 느린 테스트 케이스는 실행하지 않게 된다. 그러므로 테스트 케이스가 빨리 돌아가게 최대한 노력한다.

### 결론

<aside>
💡 가치 체계는 이 책의 주제이자 목표다. 일군의 규칙만 따른다고 깨끗한 코드가 얻어지지 않는다. 
전문가 정신과 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다.

</aside>

<br>

## 부록 A. 동시성 II

### 클라이언트/서버 예제

간단한 클라이언트/서버 애플리케이션이 있다.

- 서버: 소켓을 열어놓고 클라이언트가 연결하기를 기다린다.
- 클라이언트: 소켓에 연결해 요청을 보낸다.

성능 테스트에서 원하는 대로 10초 내에 처리가 되지 않아 실패한다면? 단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없다.

→ 다중 스레드를 사용하면 성능이 높아질까? 그럴지도 모르지만, 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다. 가능성은 다음 두 가지다.

- I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보낸다.
- 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간을 보낸다.

대게 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 대개 하나가 지배적이다.

- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면?
    
    → 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.
    
    → 프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘인다고 빨라지지 않는다. CPU 사이클은 한계가 있다.
    
- 반면 주로 I/O 연산에 시간을 보낸다면?
    
    → 동시성이 성능을 높여주기도 한다. 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용할 수 있다.
    

**스레드 추가하기**

주로 I/O 연산에 시간을 보낸다면 스레드를 추가한다.

→ 자료 처리량 향상

→ 성능 테스트 통과

```java

void process(final Socket socket) {
    if (socket == null) {
        return;
    }

    Runnable clientHandler = new Runnable() {
        public void run() {
            try {
                String message = MessageUtils.getMessage(socket);
                MessageUtils.sendMessage(socket, "Processed: " + message);
                closeIgnoringException(socket);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };

    Thread clientConnection = new Thread(clientHandler);
    clientConnection.start();
}
```

**서버 살펴보기**

위의 서버는 테스트를 완료한다. 하지만, 새로 고친 코드는 다소 부실하기에 새로운 문제를 일으킨다.

1. 새 서버가 만드는 스레드 수는 몇 개일까? 
    
    → 코드에서 한계를 명시하지 않으므로 이론상으로 JVM이 허용하는 수까지 가능하다. 대다수 간단한 시스템은 그래도 괜찮다.
    
    → 하지만 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이라면? 
    
    → 너무 많은 사용자가 시스템에 몰리면 동작을 멈출지도 모른다.
    
2.  깨끗한 코드와 구조라는 관점에서도 문제가 있다. 서버의 process 함수가 지는 책임이 너무 많다.
    - 소켓 연결 관리
    - 클라이언트 처리
    - 스레드 정책
    - 서버 종료 정책
    
    → SRP 위반
    
    → 동시성 그 자체만으로도 추적하기 어렵다. 스레드를 관리하는 코드는 스레드만 관리해야 한다.
    
    → 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다.
    

**결론**

<aside>
💡 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.

</aside>

### 가능한 실행 경로

다음 incrementValue 메서드를 살펴보자. 루프나 분기가 없는, 한 줄짜리 메서드다.

```java
public class IdGenerator {
   int lastIdUsed;

   public int incrementValue() {
      return ++lastIdUsed;
   }
}
```

스레드 하나가 IdGenerator 인스턴스 하나를 사용한다고 가정한다. 그렇다면 가능한 실행 경로는 단 하나다. 가능한 결과도 단 하나다.

→ 반환값은 lastIdUsed 값과 동일하다. 두 값 모두 메서드를 호출하기 전보다 1이 크다.

만약 IdGenarator 인스턴스는 그대로지만 스레드가 두 개라면? 초깃값을 93으로 가정할 때 가능한 결과는 다음과 같다.

- 스레드 1이 94를 얻고, 스레드 2가 95를 얻고, lastIdUsed가 95가 된다.
- 스레드 1이 95를 얻고, 스레드 2가 94를 얻고, lastIdUsed가 95가 된다.
- 스레드 1이 94를 얻고, 스레드 2가 94를 얻고, lastIdUsed가 94가 된다.

→ 놀랄지도 모르지만 마지막 결과도 가능하다. 다양한 결과가 나오는 이유를 알려면 가능한 실행 경로 수와 JVM의 동작 방식을 알아야 한다.

**경로 수**

`return ++lastIdUsed`라는 자바 코드 한 줄은 바이트 코드 명령 8개에 해당한다. 즉, 두 스레드가 8개를 뒤섞어 실행할 가능성이 충분하다.

루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로 수는 다음과 같다.

$(NT)! / N!^T$

**심층 분석**

원자적 연산: 중단이 불가능한 연산 

- lastid에 0을 할당하는 연산은 원자적이다. 하지만, long으로 바꾼다면 32비트 값을 할당하는 연산 2개로 나눠진다.
- 전처리 증가 연산자 ++ 또한 중단이 가능하다.

→ 바이트 코드를 분석해보면 중간에 서로 스레드가 끼어들며 작업을 진행하고, 덮어쓰기가 될 수도 있다.

→ 메서드를 synchronized로 선언하면 문제는 해결된다.

### 결론

어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다. 다음을 알아야 한다.

- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법

### 라이브러리를 이해하라

**Executor 프레임워크**

애플리케이션에서 스레드는 생성하나 스레드 풀을 사용하지 않는다면 혹은 직접 생성한 스레드 풀을 사용한다면 Executor 클래스를 고려하기 바란다. 코드가 깔끔해지고, 이해하기 쉬워지고, 크기가 작아진다.

→ Executor 프레임워크는 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 필요하다면 스레드를 재사용한다. + Future, Callable 인터페이스를 구현한 클래스, Runnable 인터페이스를 구현한 클래스를 지원한다.

**스레드를 차단하지 않는 방법 (non blocking)**

- 최신 프로세서는 차단하지 않고도 안정적으로 값을 갱신한다. 자바 5는 AtomicBoolean, AtomicInteger 등 여러 새로운 클래스를 지원한다.
    
    → 해당 클래스는 기본 유형 int가 아니라 객체를 사용하고, ++ 연산자가 아니라 incrementAndGet() 이라는 메서드를 사용한다. 
    
    → 새 ObjectWithValue 클래스는 이전 ObjectWithValue 클래스보다 거의 항상 더 빠르고, 엇비슷한 경우는 있겠지만 더 느린 경우는 사실상 없다.
    
- 현대 프로세서는 CAS(Compare and Swap)이라 불리는 연산을 지원한다. 데이터베이스 분야에서 낙관적 잠금이라는 개념과 유사하다. 반면 동기화는 비관적 잠금이라는 개념과 유사하다.
- synchronized 키워드는 언제나 락을 건다. 락을 거는 대가는 비싸다. 락을 거는 쪽보다 문제를 감지하는 쪽이 거의 항상 더 효율적이다.
- CAS 연산은 원자적이다. CAS 연산은 메서드가 공유 변수를 갱신하려 든다면 현재 변수 값이 최종으로 알려진 값인지 확인한다. 그렇다면 변수 값을 갱신하고 아니라면 다른 스레드가 끼어들었다는 뜻이므로 변수 값을 갱신하지 않는다.

**다중 스레드 환경에서 안전하지 않은 클래스**

본질적으로 다중 스레드 환경에서 안전하지 않는 클래스가 있다. 몇 가지 예는 다음과 같다.

- SimpleDataFormat
- 데이터베이스 연결
- java.util 컨테이너 클래스
- 서블릿

→ 클라이언트-기반 잠금 메커니즘 구현, 서버-기반 잠금 메커니즘 구현, 스레드에 안전한 집합 클래스 사용 등의 방식으로 해결한다.

### 메서드 사이에 존재하는 의존성을 조심하라

```java
// 메서드 사이에 의존성이 있는 예제
public class IntegerIterator implements Iterator<Integer> {
   private Integer nextValue = 0;

   public synchronized boolean hasNext() {
      return nextValue < 100000;
   }

   public synchronized Integer next() {
      if (nextValue == 100000)
         throw new IteratorPastEndException();
      return nextValue++;
   }

   public synchronized Integer getNextValue() {
      return nextValue;
   }
}

IntegerIterator iterator = new IntegerIterator();

while(iterator.hasNext()) {
   int nextValue = iterator.next();
   // nextValue로 뭔가를 한다.
}
```

→ 스레드가 2개 이상일 때, IntegerIterator 인스턴스 하나를 공유한다면? 

→ 마지막 경계 값 구간에서 스레드1이 작업하던 중간에 스레드2가 끼어들어 작업을 끝내면 nextValue는 100000이 되고 hasNext()가 false가 된다. 하지만 작업을 다시 실행한 스레드1은 hasNext()가 여전히 true라고 생각해 이후의 작업을 진행한다. 

→ 맨 끝에서 두 스레드가 서로를 간섭해 한 스레드가 끝을 지나쳐 예외가 발생할 가능성이 존재한다.

**해결방안**

1. **실패를 용인한다**
    
    실패해도 괜찮도록 프로그램을 조정할 수 있지만 다소 조잡한 방법이라 볼 수 있다.
    
2. **클라이언트-기반 잠금**
    
    모든 클라이언트를 다음과 같이 변경한다.
    
    ```java
    IntegerIterator iterator = new IntegerIterator();
    
    while(true) {
       int nextValue;
       synchronized (iterator) {
          if(!iterator.hasNext())
             break;
          nextValue = iterator.next();
       }
       doSometingWith(nextValue);
    }
    ```
    
    서버를 사용하는 모든 프로그래머가 락 기억해 객체에 걸었다 풀어야 하므로 다소 위험한 전략이다. 한명이라도 락을 거는 것을 깜박한다면 문제를 찾기 힘들다.
    
3. **서버-기반 잠금**
    
    IntegerIterator를 서버에서 잠근다면 클라이언트에 중복해서 락을 걸 필요가 없어진다.
    
    ```java
    // 서버 코드
    public class IntegerIteratorServerLocked {
       private Integer nextValue = 0;
       public synchronized Integer getNextOrNull() {
          if (nextValue < 100000)
             return nextValue++;
          else
             return null;
       }
    }
    
    // 클라이언트 코드
    while(true) {
       Integer nextValue = iterator.getNextorNull();
       if (next == null)
          break;
       // 뭔가를 한다.
    }
    ```
    
    일반적으로 서버-기반 잠금이 더 바람직하다.
    
    - 코드 중복이 줄어든다. 모든 클라이언트에 잠금 코드를 추가할 필요가 없어진다.
    - 성능이 좋아진다. 단일 스레드 환경으로 시스템을 배치할 경우 다중 스레드 서버 → 단일 스레드 서버로 교체만 하면 오버헤드가 줄어든다.
    - 오류가 발생할 가능성이 줄어든다. 잠금을 잊어버리는 바람에 오류가 발생할 위험은 프로그래머 한 명으로 제한된다.
    - 스레드 정책이 하나다. 서버-기반 잠근은 서버 한곳에서 정책을 구현한다.
    - 공유 변수 범위가 줄어든다. 공유 변수에 대한 정보가 서버에 숨겨진다. 문제가 생기면 살펴볼 곳이 적다.
    
    **if(서버 코드에 손대지 못한다면?)**
    
    1. ADAPTER 패턴을 사용해 API를 변경하고 잠금을 추가한다.
        
        ```java
        	public class ThreadSafeIntegerIterator {
           private IntegerIterator iterator = new IntegerIterator();
        
           public synchronized Integer getNextOrNull() {
              if(iterator.hasNext())
                 return iterator.next();
              return null;
           }
        }
        ```
        
    2. 스레드에 안전하며 인터페이스가 확장된 집합 클래스 사용 (더 좋은 방법)

### 작업 처리량 높이기

PageReader : URL 하나를 받아 해당 페이지 내용 반환

PageIterator : URL Iterator를 받아 목록에 들어있는 페이지 내용을 제공

→ 해당 코드에서 주목할 점은 synchronized 블록이 아주 작다는 사실이다. 동기화 영역은 언제나 작을수록 좋다.

**작업 처리량 계산 - 단일 스레드 환경**

- 페이지를 읽어오는 평균 I/O 시간 : 1초
- 페이지를 분석하는 평균 처리 시간 : 0.5초
- 처리는 CPU 100% 사용, I/O는 CPU 0% 사용

→ 스레드 하나가 N페이지를 처리한다면 총 실행시간은 1.5초*N

**작업 처리량 계산 - 다중 스레드 환경**

→ 스레드를 3개 사용한다면 1초에 2페이지를 처리할 수 있어 단일 스레드보다 처리율이 3배가 된다.

### 데드락

개수가 한정된 자원 풀 두 개를 공유하는 웹 애플리케이션이 있다고 가정하자.

- 로컬 임시 데이터베이스 연결 풀
- 중앙 저장소 MQ 연결 풀

애플리케이션은 생성과 갱신이라는 연산 두 개를 수행한다.

- 생성 - 중앙 저장소 연결을 확보한 후 임시 데이터베이스 연결을 얻는다. 중앙 저장소와 통신한 후 임시 데이터베이스에 작업을 저장한다.
- 갱신 - 임시 데이터베이스 연결을 확보한 후 중앙 저장소 연결을 얻는다. 임시 데이터베이스에서 작업을 읽어 중앙 저장소로 보낸다.

만약 풀 크기보다 사용자 수가 많다면? 두 풀 크기를 각각 10이라 가정

- 생성 시도 10개로 중앙 저장소 연결 10개 확보. 데이터베이스 연결 대기
- 갱신 시도 10개로 데이터베이스 연결 10개 확보. 중강 저장소 연결 대기
- 생성 스레드 10개와 갱신 스레드 10개는 각각 서로가 확보한 연결을 얻기 위해 무한 대기 상태

→ 데드락 발생

**데드락 발생 조건**

1. **상호 배제**
    
    여러 스레드가 한 자원을 공유하나 그 자원은 1. 여러 스레드가 동시에 사용하지 못하며 2.개수가 제한적이라면 상호 배제 조건을 만족한다.
    
2. **잠금 & 대기**
    
    일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.
    
3. **선점 불가**
    
    자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드는 그 자원을 빼앗지 못한다.
    
4. **순환 대기**
    
    T1, T2라는 스레드 두 개가 있으며 R1, R2라는 자원 두 개가 있다고 가정하자. T1이 R1을 점유하고, T2가 R2를 점유한다. 또한 T1은 R2가 필요하고 T2도 R2가 필요하다.
    
    <img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F26444B4858FAF76031" width=400>
    
    ref.https://copycode.tistory.com/72
    

→ 네 조건을 모두 충족해야 데드락이 발생한다. 조건이 하나라도 깨진다면 데드락은 발생하지 않는다.

**상호 배제 조건 깨기**

- 동시에 사용해도 괜찮은 자원을 사용한다. 예를 들어, AtomicInteger를 사용한다.
- 스레드 수 이상으로 자원을 늘린다.
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.

→ 대다수 자원은 그 수가 제한적인 데다 동시에 사용하기도 어렵다. 게다가 첫 번째 자원을 사용하고 나서야 두 번째로 필요한 자원이 밝혀지는 경우도 없지 않다.

**잠금 & 대기 조건 깨기**

대기하지 않으면 데드락이 발생하지 않는다. 각 자원을 점유하기 전에 확인한다. 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작한다.

**이 방법의 잠재적인 문제점**

- 기아 - 하나 스레드가 계속해서 필요한 자원을 점유하지 못한다.
- 라이브락 - 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 내놨다를 반복한다.

→ 두 경우 모두가 자칫하면 작업 처리량을 크게 떨어뜨린다. 기아는 CPU 효율을 저하시키는 반면, 라이브락은 쓸데없이 CPU만 많이 사용한다.

**선점 불가 조건 깨기**

다른 스레드로부터 지원을 뺏어오는 방법이다. 일반적으로 필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라고 요청한다. 소유 스레드가 다른 자원을 기다리던 중이었다면 자신이 소유한 자원을 모두 풀어주고 처음부터 다시 시작한다.

→ 앞서 언급한 전략과 비슷하지만, 스레드가 자원을 기다려도 괜찮다는 이점이 있다. 그러면 처음부터 다시 시작하는 횟수가 줄어든다. 하지만 이 모든 요청을 관리하기가 그리 간단하지 않다.

**순환 대기 조건 깨기**

데드락을 방지하는 가장 흔한 전략이다. 대다수 시스템에서는 모든 스레드가 동의하는 간단한 규약이면 충분하다모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락을 불가능하다. 

**해당 방법의 문제점**

- 자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모른다. 그래서 맨 처음 할당한 자원을 아주 나중에야 쓸지도 모른다. 즉, 자원을 필요한 이상으로 오랫동안 점유한다.
- 때로는 순서에 따라 자원을 할당하기 어렵다. 첫 자원을 사용한 후에야 둘째 자원 ID를 얻는다면 순서대로 할당하기란 불가능하다.

**결론**

이렇게 데드락을 피하는 전략을 많다. 어떤 전략은 기아를 일으키고, 어떤 전략은 CPU를 심하게 사용해 응답도를 낮춘다.

> 공짜 점심은 없다! (There ain’t no such thing as a free lunch)
> 

**다중 스레드 코드 테스트**

코드에 버그가 있다는 사실을 증명할 테스트 케이스 작성 방법

- 몬테 카를로 테스트: 조율이 가능하게 유연한 테스트를 만든다. 그런 다음, 임의로 값을 조율하면서 반복해 돌린다. 테스트가 실패하면 버그가 있다는 증거다.
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다. 반복해서 돌린다. 테스트가 실패 없이 오래 돌아갈수록 두 가지 중 하나일 확률이 높아진다.
    - 실제 코드가 올바르다.
    - 테스트가 부족해 문제를 드러내지 못한다.
- 부하가 변하는 장비에서 테스트를 돌린다. 실제 환경과 비슷하게 부하를 걸어 줄 수 있다면 그렇게 한다.

하지만, 이런 조치를 모두 최하더라도 스레드 문제를 찾아낼 가능성은 매우 낮다. 십억 번에 한 번씩만 일어나는 희귀한 문제가 가장 골치 아프다.

**스레드 코드 테스트를 도와주는 도구**

IBM의 ConTest: 스레드에 안전하지 않는 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구

→ 해당 도구를 적용하면 천만 번에 한 번 정도 실패하던 코드가 서른 번에 한 번 정도 실패한다.
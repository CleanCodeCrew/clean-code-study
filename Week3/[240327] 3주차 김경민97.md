# [240327] 3주차

# 8장 경계

### 외부 코드 사용하기

- 경계 인터페이스를 안으로 숨겨 사용자가 세부 구현을 모르게 한다.
- Map과 같은 경계 인터페이스는 이를 이용하는 클래스 밖으로 노출되지 않도록 주의한다.

### 경계 살피고 익히기

- 학습 테스트: 외부 코드를 호출하는 대신 간단한 테스트 케이스를 작성
- 프로그램이 사용하려는 방식대로 외부 API를 호출.
API 사용 목적에 초점

### log4j 익히기

- 직관적인 코드부터 작성하고 에러를 수정하며 올바른 사용법을 익힌다.

### 학습 테스트는 공짜 이상이다

- 드는 비용도 없고 필요한 지식만 확보하는 정확한 실험이다.
- 새 버전에서 호환되지 않는 부분 발생해도 학습 테스트에 의해  검증된다.

### 아직 존재하지 않는 코드를 사용하기

- 바라는 인터페이스를 구현하면 우리가 전적으로 통제할 수 있다.
가독성+, 코드 의도 +
- Adapter 패턴으로 API 사용 캡슐화 가능
- 인터페이스가 정해져 있어 Mock 객체로 테스트도 편리하다.

### 깨끗한 경계

- 설계가 우수하다면 변경 시 많은 투자가 필요하지 않다.
- 경계에 위치하는 코드는 깔끔히 분리하고, 기대치를 정의하는 테스트 케이스를 작성한다.
- 외부 패키지가 아닌 통제 가능한 코드에 의존하자.
- 새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용해 인터페이스로 변환

### 

# 9장 단위 테스트

### TDD 법칙 세 가지

1. 실패하는 단위 테스트 작성 전까지 실제 코드 작성 X
2. 컴파일 성공하고 실행 실패 정도로만 단위 테스트 작성
3. 실패하는 테스트 통과할 정도로만 실제 코드 작성

- 개발과 테스트가 30초 주기로 묶인다.
- 테스트 코드와 실제 코드가 함께 나오고, 테스트 코드가 몇 초 전에 나온다.
- 매일 수십 개에 달하는 테스트 케이스가 나온다.

하지만 방대한 테스트 코드는 관리 문제 또한 유발한다.

### 깨끗한 테스트 코드 유지하기

- 지저분한 테스트 코드는 없느니만 못하다. 실제 코드가 진화하면 테스트 코드도 변해야 한다.
- 지저분한 테스트 코드는 실패하는 케이스가 증가하고, 점점 통과하기 어려워지고 결국 폐기하면 결함율이 높아진다.
- 테스트는 유연성, 유지보수성, 재사용성 제공
    - 테스트 케이스 없이는 모든 변경이 잠정적 버그

### 깨끗한 테스트 코드

- 가독성이 중요하다.
명료하고, 단순하고, 표현력
- Build - Operate - Check 패턴
- 테스트 코드는 꼭 실제 코드만큼 효율적일 필요는 없다.
메모리나 CPU 효율 등은 코드의 깨끗함과는 무관

### 테스트 당 assert 하나

- 테스트당 assert 하나는 테스트 코드를 읽기 쉽게 만든다.
- 가능한 줄이면 좋지만 꼭 하나여야 할 필요는 없다.
- ‘테스트당 개념 하나’가 더 적합

### F.I.R.S.T

- “F”ast: 테스틑 빨리 돌아야 자주 돌릴 수 있고, 초반에 문제를 찾아내고 정리하기 쉽다.
- “I”ndependent: 각 테스트는 서로 의존하면 안된다. 실패 원인 진단하기 어렵고 결함이 숨겨진다.
- “R”epetable: 어떤 환경에서도 반복 가능해야 한다.
- “S”elf-Validating: 테스트는 스스로 성공/실패 값으로 결과를 내야 한다.
- “T”imely: 테스트는 적시에 작성해야 한다. 실제 코드 구현 후 작성 시 테스트 어렵거나 불가능 할 수 있다.

### 

# 10장 클래스

### 클래스 체계

- 변수 (static, public → private) → public 함수 → private
추상화 단계가 순차적으로 내려간다.
- 캡슐화
    - 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫다.
    - 때로는 protected로 선언해 패키지 접근 또는 테스트 용이성

### 클래스는 작아야 한다!

- 작은 클래스 = 물리적 크기가 아닌 ‘책임’의 수
    - 클래스 이름은 해당 클래스 책임을 기술
    - Processor, Manager, Super 등 모호한 이름은 너무 많은 책임의 징조
- 단일 책임 원칙
    - 클래스나 모듈을 변경할 이유(=책임)가 단 하나여야 한다.
- 응집도
    - 인스턴스 변수 수가 작아야 한다.
    - 각 메서드는 인스턴스 변수를 하나 이상 사용해야 한다.
    - 일부 메서드만 사용하는 인스턴스 변수가 많다 → 새로운 클래스
- 응집도를 유지하면 작은 클래스 여럿이 나온다
    - 큰 함수를 작은 함수로 쪼개는 과정
    - 몇몇 함수가 몇몇 변수만 사용 → 응집도를 잃은 클래스는 쪼개라

### 변경하기 쉬운 클래스

이상적인 시스템은 새 기능 추가 시 시스템을 확장할 뿐 기존 코드를 변경하지 않는다.

- 변경으로부터 격리
    - 상세 구현에 의존하는 코드는 테스트하기 어렵다.
    - 결합도 낮추면 유연성 재사용성 증가, 변경으로부터 격리
    - DIP를 따르는 클래스가 나온다.

### 

# 11장 시스템

### 도시를 세운다면?

- 한 사람의 힘으로는 무리다. 적절한 추상화와 모듈화 필요

### 시스템 제작과 시스템 사용을 분리하라

설정(시작 단계)은 실행과 분리해야 한다.

- Main 분리
    - 생성 관련 코드는 모두 main 관련 모듈로 옮긴다.
    - 모든 의존성은 main에서 애플리케이션을 향한다.
    - main에서 전부 생성하고, 이를 가정하고 애플리케이션은 사용만 한다.
- 팩토리
    - 추상 팩토리 패턴: 생성 시점은 애플리케이션이 결정하지만 생성 코드(구현)는 모른다.
- 의존성 주입
    - 사용과 제작을 분리하는 강력한 메커니즘으로, 제어 역전을 의존성 관리에 적용한 기법
    - 클래스 또한 스스로 의존성 해결하지 않고, setter나 생성자 인수 제공
    - 스프링 프레임워크는 자바 DI 컨테이너 제공

### 확장

- 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다.
- 소프트웨어 시스템은 ‘수명이 짧다’는 본질 → 아키텍처 점진적 발전 가능
- 횡단 관심사: 일부 영역에 걸친 관심사를 분리한다.

### 자바 프록시

- 단순한 상황에 적합(개발 객체나 클래스에서 메서드 호출 감싸는 경우)
- JDK 제공 동적 프록시는 인터페이스만 지원
    - 클래스 프록시를 위해서는 CGLIB, ASM, Javassis 등 바이트 코드 처리 라이브러리 필요

### 순수 자바 AOP 프레임워크

- 스프링 AOP, JBossAOP 등은 내부적으로 프록시 사용
- 스프링은 비즈니스 로직을 POJO로 구현, 순수하게 도메인에 초점
- xml에 객체 설정 명시, 스프링과 애플리케이션을 독립적으로 만듦
그치만 너무 구식이지 않나.. 애노테이션 기반으로 추세가 바뀌면서 다시 스프링 종속적인듯

### AspectJ 관점

- 관심사를 분리하는 강력한 도구
- 순수 자바 코드에 애노테이션(Java5~)를 사용해 관점 정의

### 테스트 주도 시스템 아키텍처 구축

- 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 = 코드 수준 아키텍처 관심사 분리
    - 진정한 테스트 주도 아키텍처 구축 가능

### 의사 결정을 최적화하라

- 가장 적합한 사람에게 책임을 맡기는 것이 좋다.
- 가능한 결정을 미루는 방법이 때로는 최선
    - 고객 피드백을 모으고, 프로젝트를 고민하고, 방법을 탐험할 기회 사라짐

### 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 과장되게 포장된 표준에 집착하지 말자
- 때로는 표준을 만드는 시간이 너무 오래걸려 업계가 기다리지 못한다.
    
    사실 저연차때는 표준을 무작정 따라가기도 쉽지 않음. 그래도 비판적으로 보자.
    

### 시스템은 도메인 특화 언어가 필요하다

- 좋은 DSL은 도메인 개념과 구현 코드 사이 간극을 줄여준다.

### 결론

- 시스템은 깨끗해야 한다. 그렇지 못한 아키텍처는 도메인 논리를 흐리고 기민성을 떨어뜨린다.
- 품질이 떨어지고 버그가 생기고 생산성이 낮아진다.
- 결국 **실제로 돌아가는 가장 단순한 수단**을 사용해야 한다.
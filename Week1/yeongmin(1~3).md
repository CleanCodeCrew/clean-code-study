
## 1장

코드가 존재하리라
- 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업이 프로그래밍이다.
- 코드는 요구사항을 표현하는 언어이다.
- 수준 높고 정밀한 표현을 위해서는 코드는 존재할 것이다.

나쁜 코드
- 이전 버전에 있었던 버그가 다음 버전에도 그대로 남아 있듯이 나쁜 코드는 쉽게 바꿀 수 없다.
- 나쁜 코드는 회사가 망할 수 있는 원인이 될 수 있다.
- 코드를 작성 초기에는 르블랑의 법칙의 `나중은 결코 오지 않는다` 를 생각하자.

나쁜 코드로 치르는 대가
- 팀 생산성 저하
	나쁜 코드가 쌓이면 0에 근접하여 생산성이 떨어지고 생산성을 증가 시키려고 
	프로젝트에 인력을 추가로 투입한다.
	하지만 새 인력은 시스템의 구조 및 설계를 이해하지 못하고 부담감이 커지게되어
	나쁜 코드를 더 많이 양산하게 된다.
- 기존 시스템을 대체하는 새 시스템을 만드는 것보다는 기존에 시간을 들여 깨끗한 코드를 만드는 노력으로 비용을 절감할 뿐만 아니라 전문가로서 살아남는 길일 수 있다.

태도
- 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동이 아닌 좋은 코드를 사수하는 것은 우리 프로그래머들의 책임이다.

원초적 난제
- 기한을 맞추기 위한 나쁜 코드를 양산하는것은 기한을 맞추지 못한다.
- 기한을 최대한 맞추기 위한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

깨끗한 코드라는 예술?
- 코드 감각을 통해서 나쁜 모듈,코드를 개선할 수 있어야한다.

깨끗한 코드란?
- 비야네 스트롭스트롭(Bjarne Stroustrup)
	1. 깨끗한 코드는 '보기에 즐거운' 코드다.
	2. 나쁜 코드는 더 나쁜 코드를 유혹한다.
	3. 세세한 사항까지 꼼꼼하게 처리하는 코드여야 한다.
	4. 클래스와 모듈은 한 가지에 집중한다.

- 그래디 부치(Grady Booch)
	1. 코드는 잘 쓴 문장처럼 읽혀야한다.
	2. 해결할 문제의 긴장을 명확히 드러내야 한다.

- 큰 데이브 토마스
	1. 깨끗한 코드는 다른 사람이 고치기 쉽다.
	2. 깨끗한 코드는 테스트 코드를 작성한다.
	3. 코드는 작을 수 록 좋다.
	4. '문학적'인 읽기 쉬운 코드를 작성해야한다.

- 마이클 페더스
	1. 깨끗한 코드는 언제나 주의 깊게 짰다는 느낌을 준다.

- 론 제프리스
	1. 같은 기능을 수행하는 작업의 중복이 없어야 한다.
	2. 하나의 기능만 수행해야한다.
	3. 표현력 - 어떤 기능을 담당하는지 의미 있는 이름을 포함한다.
	4. 간단한 추상화를 고려하자.

- 워드 커닝햄
	1. 짐작한 대로 돌아가는(명백하고 단순한) 코드는 깨끗한 코드이다.

우리들 생각
- 읽기 쉬운 코드를 구성해라
- 보이스카우트 규칙 - 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다.


## 2장
의도를 분명히 밝혀라
- 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.
- 따로 주석이 필요하다면 의도를 분명히 드러내지 못한 것이다.
- 메서드의 기능에 관련된 명칭, 변수의 역할에 관련된 명칭을 분명히 정하자.

그릇된 정보를 피하라
- 코드에 그릇된 단서를 남겨서는 안된다.
  ex) List를 형태를 가진 변수에만 List를 붙여야 한다.
- 널리 사용되고 있는 단어를 사용하지 말아야 한다.
- 서로 흡사한 이름을 사용하지 않도록 한다.

의미 있게 구분하라
- 불용어를 추가하는 이름은 아무런 정보를 제공하지 못한다.
  ex) char a1[], char a2[]
- 불용어는 중복이다.

발음하기 쉬운 이름을 사용하라
- 발음을 하기 어려운 이름은 토론하기도 어렵다.

검색하기 쉬운 이름을 사용하라
- 상수는 문자화하여 의미를 분석할 수 있도록 해야한다.
```
for (int i = 0; i < 34; i ++) {}

// 상수로 만들어서 사용
final String MAX_CASSES_PER_STUDENT = 34;

for (int i = 0; i < MAX_CASSES_PER_STUDENT; i++) { }
```
- 간단한 메서드에서 로컬 변수만 한 문자를 사용한다.
- 이름 길이는 범위 크기에 비례해야한다.

인코딩을 피하라
- 변수, 함수, 클래스 이름이나 타입을 바꾸기 어렵기 때문에 변수 이름에 타입을 인코딩할 필요는 없다.
	ex) PhoneNumber phoneString; 

멤버 변수 접두어
- 클래스와 함수는 접두어가 필요 없을 정도로 작아야 마땅하다.
- 멤버 변수를 다른 색상으로 표시하거나 눈에 띄게 보여주는 IDE를 사용하자.

인터페이스 클래스와 구현 클래스
- 인터페이스와 구현 클래스 이름 중 하나를 인코딩 해야한다면 구현 클래스명 Imp을 추천한다.

자신의 기억력을 자랑하지 마라
- 자신만 아는 이름보다는 일반적으로 사용되는 이름을 사용하여 남들이 이해할 수 있는 코드여야 한다.

클래스 이름
- 클래스와 객체 이름은 명사나 명사구가 적합하고 Data, Info와 같은 단어는 피하고 동사는 사용하지 않는다.

메서드 이름
- 동사나 동사구가(postPayment, deletePage) 적합하며 접근자, 변경자, 조건자는 get,set,is를 붙인다.
- 생성자를 private으로 선언하고 정적 팩토리 메서드를 통해서 객체를 생성해야한다.

기발한 이름은 피하라
- 농담, 재미난 이름보다는 명료한 이름을 선택해야한다.

한 개념에 한 단어를 사용하라
- 조회를 예시로 fetch, retrieve, get 중 하나의 단어만을 사용해야한다.
- 주석을 확인하지 않고도 메서드 이름을 알 수 있도록 메서드 이름은 독자적이고 일관적이여야 한다.

말장난을 하지 마라
- 한 단어를 두 가지 목적으로 사용하지 않는다.

해법 영역에서 가져온 이름을 사용하라
- 코드를 읽을 사람도 프로그래머라는 사실을 명심한다.
- 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 된다.
- 모든 이름을 도메인에서 가져오는 것은 현명하지 못하다.
- 기술 개념에는 기술 이름이 가장 적합한 선택이다.

문제 영역에서 가져온 이름을 사용하라
- 적절한 프로그래머 용어가 없다면 문제 영역에서 이름을 가져온다.
- 해법 영역과 문제 영역을 구분할 줄 알아야한다.
- 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야한다.

의미 있는 맥락을 추가하라
- 의미가 분명하지 않다면 클래스, 함수, 이름 공간에 넣어 맥락을 부여한다.
- 접두어를 추가하여 더 의미 있는 맥락으로 만들자.

불필요한 맥락을 없애라
- 의미가 분명한 경우에 한해서 짧은 이름이 긴 이름보다 좋다.
- 이름에 불필요한 맥락을 추가하지 않도록 주의한다.


## 3장
작게 만들어라
- 함수를 만드는 첫째 규칙은 `작게`, 둘째 규칙은 `더 작게`이다.

블록과 들여쓰기
- if 문 /else 문 /while 문 등에 들어가는 블록은 한 줄이어야 한다.
- 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

한 가지만 해라
- 함수는 한 가지를 해야한다.
- 한 가지를 잘 해야 한다.
- 그 한 가지만을 해야 한다.
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업을 한다.
- 하나의 함수가 둘 이상의 의미 있는 함수로 만들 수 있다면 그 함수는 여러 작업을 하는 것이다.
ex)
```
public static String renderPageWithSEtupsAndTeardowns(
	PageData pageData, boolean isSuite) throws Exception {

	// 1. 페이지가 테스트 페이지인지 판단한다.
	if(isTestPage(pageData))
		// 2. 그렇다면 설정 페이지와 해제 페이지를 넣는다.
		includeSetupAndTeardownPages(pageData, isSuite);

	// 3. 페이지를 HTML로 렌더링한다.
	return pageData.getHtml();
	
	}
}
```

함수당 추상화 수준은 하나로
- 함수가 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일 해야 한다.
- 함수 내에 근본 개념과 세부사항이 뒤섞여 있다면 깨어진 창문처럼 다른 사람들이 함수에 세부사항을 점점 더 추가한다.

위에서 아래로 코드 읽기: 내려가기 규칙
- 한 함수 다음에 한 단계 낮은 함수가 오도록 코드는 위에서 아래로 이야기처럼 읽어야 좋다.
- 위에서 아래로 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기가 쉬워진다.

Switch 문
- 함수가 길어진다.
- 한 가지 작업만을 수행하지 않는다.
- SRP와 OCP를 위반한다.

서술적인 이름을 사용하라
- 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
- 길고 서술적인 이름이 어려운 이름보다 좋다.
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 함수 이름은 여러 단어가 쉽게 읽히는 명명법으로 함수 기능을 잘 표현하는 이름을 선택한다.
- 이름을 붙일 때는 일관성이 있어야 한다.

함수 인수
- 인수는 3개 이상은 피하는게 좋다.
- 인수가 많다면 인수 마다 유효한 값으로 모든 조합을 구성해 테스트하기가 어렵다.
- 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다.

많이 쓰는 단항 형식
- 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.
	ex) void includeSetupPageInto(StringBuffer pageText)
- 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.
	ex) void transform(StringBuffer out)보다 좋다.
```	
public void main() {
	StringBuffer stringBuffer = new StringBuffer();
	
	transform(stringBuffer);
	// 입력인 수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.
	// 아래와 같이
	stringBuffer = transform(stringBuffer);

}

private StringBuffer transform(StringBuffer in) {}
```
	
플래그 인수
- 파라미터로 boolean 값을 넘기지 않는다.

이항 함수
- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 단항 함수로 바꿔서 호출할 수 있도록 변경한다.

삼항 함수
- 인수가 3개인 함수는 인수가 2개인 함수보다 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.

인수 객체
- 파라미터들을 객체로 변환하고 의미 있는 이름을 작성해라.

동사와 키워드
- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
- 함수 이름에 인수 이름을 넣는다면 인수 순서를 기억할 필요가 없어진다.

부수 효과를 일으키지 마라
-  부수 효과를 일으키고 한 가지의 기능을 담당하지 않다면 함수 이름을 분명히 명시한다.

출력 인수
- 일반적으로 출력 인수는 피해야 한다.
- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

명령과 조회를 분리하라
- 함수는 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중에 하나만 해야한다.
```
// 수정되어야할 파라미터가 어떤건지 모호하다.
if (set("username","unclebob"))

// username이 존재하는지
if(attributeExists("username")) {
	// username을 unclebob으로 수정
	setAttribute("username", "unclebob);
}
```

오류 코드보다 예외를 사용하라
- 에러 코드를 반환하여 사용하는 것보다 예외 처리를 사용해라.
- try catch 블록은 별도 함수로 뽑아내는 편이 좋다.
- 오류를 처리하는 메서드와 실제 동작을 하는 메서드로 분리하면 코드를 이해하고 수정하기 쉬워진다.
```
// 오류 처리를 담당하는 메서드
public void delete(Page page) {
	try {
		deletePageAndAllReferences(page);	
	} catch (Exception e) {
		logError(e);
	}
}

// 실제 동작을 담당하는 메서드
public void deletePageAndAllReferences(Page page) throws Exception {
	deltePage(page);
	registry.deleteReference(page.name);
	configKeys.deleteKey(page.name.makeKey());
}
```

구조적 프로그래밍
- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.
  즉, 함수는 return 문이 하나여야 한다.
- 루프 안에서 break나 continue, goto를 사용해선 안된다.
- 함수를 작게 만든다면 return, break, continue를 여러 차례 사용해도 괜찮다.

함수를 어떻게 짜죠?
1. 코드를 다듬는다.
2. 함수와 이름을 바꾼다. 
3. 중복을 제거한다. 
4. 메서드를 줄이고 순서를 바꾼다.
5. 전체 클래스를 쪼갠다.
- 처음에는 길고 복잡하지만 위와 같은 과정을 통해서 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수가 나올 수 있다.
- 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어가기 쉬워진다.
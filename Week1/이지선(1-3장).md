# 1주차 요약 정리

## 1장. 깨끗한 코드

### **코드가 존재하리라**

기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 바로 이것이 프로그래밍이다. 이렇게 명시한 결과가 바로 코드다.

궁극적으로 코드는 요구사항을 **표현**하는 언어라는 사실을 명심한다. 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있다. 하지만 어느 순간에는 정밀한 표현이 필요하다. 그 필요성을 없앨 방법은 없다. 그러므로 코드도 항상 존재하리라.

### 나쁜 코드

커다란 인기를 얻었던 킬러 앱 회사가 망한 원인은 바로 나쁜 코드 탓이었다. 자세히 말하자면 출시에 바빠 코드를 마구 짜고, 여기에 기능을 추가할수록 코드는 엉망이 되었다. 결국엔 감당이 불가능한 수준까지 온 것이다.

우리 모두는 자신이 짠 쓰레기 코드를 나중에 손보겠다고 생각한 경험이 있다. 하지만 **나중은 결코 오지 않는다.** 

> **Later equals never!**
> 

### 나쁜 코드로 치르는 대가

나쁜 코드가 쌓일수록 팀 생산성은 떨어지고, 그러마다 마침내 0에 근접한다.

- 원대한 재설계의 꿈
    - 유능하고 똑똑한 사람들만으로 구성된 타이거 팀이 구성된다. 나머지는 계속해서 현재 시스템을 유지보수한다. 타이거팀은 기존 시스템 기능을 모두 제공하는 새 시스템과 그 동안 가해지는 변경도 모두 따라잡아야 한다.
    - 새 시스템이 기존 시스템을 따라잡을 즈음이면 초창기 타이거 팀원들은 모두 집을 떠났고 새로운 팀원들이 현재 시스템이 너무 엉망이라서 새 시스템을 설계하자고 나선다.
    - 즉, 깨끗한 코드를 만드는 노력 = 비용 절감 + 전문가로서 살아남는 길
- 태도
    - 관리자, 사용자, 프로젝트 관리자는 우리에게 정보를 구하고, 도움을 청하는 등 프로젝트를 계획하는 과정에 깊숙히 관여한다. 그러므로 프로젝트 실패는 우리에게도 커다란 책임이 있다.
    - 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.
- 원초적 난제
    - 기한을 맞추는 유일한 방법 = 빨리 가는 유일한 방법 = 언제나 코드를 최대한 깨끗하게 유지하는 습관
- 깨끗한 코드라는 예술?
    - 깨끗한 코드를 작성하려면 ‘코드 감각’을 습득해서 자잘한 기법들을 적용하는 절제와 규율이 필요하다.
- 깨끗한 코드란?
    - 비야네 스트롭스트룹
        - 우아하고 효율적인 코드
        - 보기에 즐거운 코드
        - 나쁜 코드는 나쁜 코드를 유혹한다.
    - 데이브 토마스, 앤디 헌트
        - 깨져버린 창문 → 창문이 더 깨져도 상관 X → 자발적으로 창문을 깸 → 더 큰 쇠퇴 과정 진행
    - 그래디 부치
        - 깨끗한 코드는 잘 쓴 문장처럼 가독성이 좋다.
        - 명쾌한 추상화와 단순한 제어문으로 가득하다. → 반드시 필요한 내용만 담는다.
    - big 데이브 토마스
        - 깨끗한 코드는 다른 사람도 일기 쉽고 고치기 쉽다.
        - 테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.
    - 마이클 페더스
        - 깨끗한 코드는 ‘주의’깊게 짰다는 느낌을 준다. → 세세한 사항까지 꼼꼼하게 신경 쓴 코드
    - 론 제프리스
        - 중복을 피하라
        - 한 기능만 수행하라
        - 제대로 표현하라
        - 작게 추상화하라
    - 워드 커닝햄
        - 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드다.
        - 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다.

### 우리는 저자다

우리는 저자다. 그리고 저자에게는 독자와 잘 소통할 **책임**도 있다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10대 1을 훌쩍 넘는다. 그러므로 읽기 쉽게 만들어야 한다.

### 보이스카우트 규칙

시간이 지나도 언제나 깨끗하게 유지해야 한다. 적극적으로 코드의 퇴보를 막아야 한다.

한번에 많은 시간과 노력 투자 X → 변수 이름 개선, 조금 긴 함수 분할, 약간의 중복 제거, 복잡한 if문 정리같이 지속적인 개선 필요

### 결론

예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다. 단지 소개할 뿐. 이 책의 정보와 경험을 통해 직접 배워야 한다.

```
💡 1장 후기

나쁜 코드는 나쁜 코드를 유혹한다는 부분이 인상깊다. 나쁜 코드로 시작되면 더 큰 나쁜 코드가 되어 걷잡을 수 없는 경우가 많다. 시간이 좀 더 들더라도 처음부터 깨끗한 코드를 작성하도록 노력해야 한다. 여기에 더해 지속적인 개선은 전문가 정신의 본질이라는 말을 새겨놓아야겠다. 그 당시엔 최선의 코드였어도 시간이 지나서 과거의 코드를 보면 개선할 수 있는 부분이 보이기 마련이다. 
```


## 2장. 의미 있는 이름

### 의도를 분명히 밝혀라

의도가 분명한 이름은 **정말로** 중요하다. 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다. 

변수나 함수 그리고 클래스 이름은 다음과 같은 질문에 모두 답할 수 있어야 한다.

- 변수(혹은 함수나 클래스)의 존재 이유는?
- 수행 기능은?
- 사용 방법은?

### 그릇된 정보를 피하라

일관성이 떨어지는 표기법은 그릇된 정보다. 

1. 코드에 그릇된 단서를 남겨서는 안된다. 
2. 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다. 
3. 서로 흡사한 이름을 사용하지 않도록 주의한다.

### 의미 있게 구분하라

컴파일러나 인터프리터만 통과하려는 식으로 연속된 숫자나 불용어를 추가하는 방식은 적절하지 못하다.

읽는 사람이 차이를 알도록 이름을 짓는다.

### 발음하기 쉬운 이름을 사용하라

발음하기 쉬운 이름을 선택한다. 

```java
(X) genymdhms 
(O) generationTimestamp 
```

### 검색하기 쉬운 이름을 사용하라

문자 하나를 사용하는 이름과 상수는 해당 문자가 들어가는 모든 파일 이름과 수식이 검색된다. 이름 길이는 범위 크기에 비례해야 한다.

### 인코딩을 피하라

- 헝가리식 표기법
    
    변수 이름에 타입을 인코딩할 필요가 없다. IDE의 발달로 코드를 컴파일하지 않고도 타입 오류를 감지할 수 있다. ex) phoneString
    
- 멤버 변수 접두어
    
    클래스와 함수는 접두어가 필요없을 정도로 작아야 한다. 그리고 코드를 읽을수록 접두어를 무시하기 때문에 사용에 의미가 없다. ex) m_dsc
    
- 인터페이스 클래스와 구현 클래스
인터페이스 이름은 접두어를 붙이지 않는 편이 좋다. 인코딩해야 한다면 구현 클래스 이름을 택하는 것이 좋다.

### 클래스 이름

클래스 이름과 객체 이름은 명사나 명사구가 적합하고, 동사는 사용하지 않는다.

```json
// Good words👍
Customer
WikiPage
Account

// bad words👎
Manager
Processor
Data
Info
```

### 메서드 이름

메서드 이름은 동사나 동사구가 적합하다. 

생성자를 overload할 때는 정적 팩토리 메서드를 사용한다. 메서드는 인수를 설명하는 이름을 사용한다.

```json
// Good👍
Complex fulcrumPoint = Complex.FromRealNumber(23.0);

// bad👎
Complex fulcrumPoint = new Complex(23.0);
```

### 한 개념에 한 단어를 사용하라

추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 각각 다르게 부르면 혼란스럽다. 

메서드 이름은 독자적이고 일관적이야 한다.

동일 코드 기반에 controller, manager, driver를 섞어쓰면 안된다. 이름이 다르면 당연히 클래스도 다르고 타입도 다를거라고 생각하게 된다.

### 말장난을 하지 마라

한 단어를 두 가지 목적으로 사용하지 않는다.

1. 기존 값 두 개를 더하거나 이어서 새로운 값을 만드는 add 메서드
2. 집합에 값 하나를 추가하는 add 메서드

두 메서드는 서로 맥락이 다르다. 2번째 메서드는 insert or append라는 이름이 더 적합하다.

### 해법 영역에서 가져온 이름을 사용하라

코드를 읽을 사람도 프로그래머이기 때문에 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어등을 사용해도 괜찮다. 기술 개념에는 기술 이름이 가장 적합한 선택이다.

### 문제 영역에서 가져온 이름을 사용하라

적절한 ‘프로그래머 용어’가 없다면 문제 영역에서 이름을 가져온다. 그러면 코드를 보수하는 프로그래머가 전문가에게 의미를 물어 파악할 수 있다.

### 의미 있는 맥락을 추가하라

클래스, 함수, 이름 공간에 넣어 맥락을 부여한다. 

### 불필요한 맥락을 없애라

Gas Station Deluxe라는 애플리케이션의 모든 클래스의 이름을 GSD로 시작하는 건 전혀 바람직하지 못하다. 이름에 불필요한 맥락을 추가하지 않도록 주의해야 한다.

### 마치면서

좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다. 

```
💡 2장 후기

책의 예시로 변수명에 list를 쓰는 것에 대해 실제 list가 아니면 그릇된 정보를 제공하는 것이고, list이더라도 컨테이너 유형을 이름에 넣지 않는 편이 바람직하다고 한다. 여러개의 정보를 담을 때 목록이라는 의미로 변수명에 list를 사용한 적이 꽤 많은데 이 이름으로 인해 그릇된 정보를 제공할 수 있고, 추후 자료형이 바뀔 수도 있기 때문에 앞으론 지양해야겠다.
2장을 마무리하며 저자는 좋은 이름을 선택하려면 문화적인 배경이 같아야 한다고 말한다. 한국인인 입장으로 영어 단어의 미묘한 어감 차이를 인지하며 이름을 짓는 건 참 힘들다. 역시 프로그래머와 영어는 떼려야 뗄 수 없는 관계인 것 같다. 영어 공부도 열심히 하기!!
```

</br>

## 3장. 함수

### 작게 만들어라!

함수를 만드는 첫째 규칙은 **‘작게!’**, 둘째 규칙은 **‘더 작게!‘** 이다. 하나의 함수는 하나의 기능을 해야 한다.

- 블록과 들여쓰기
    
    if/else 문, while 문 등에 들어가는 블록은 한 줄이어야 한다. 거기서 함수를 호출한다.
    

### 한 가지만 해라!

> **함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**
> 

그렇다면 ‘한 가지’란 무엇일까? 

: 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 한 가지 작업만 한다.

: 의미있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 함수 당 추상화 수준은 하나로!

함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 한 함수 내에 추상화 수준을 섞으면 안된다. 근본 개념과 세부사항을 뒤섞기 시작하면, 함수에 세부사항을 점점 더 추가하기 마련이다.

- 위에서 아래로 코드 읽기: 내려가기 규칙
    
    한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. → 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 각 함수는 다음 함수를 소개한다.
    

### Switch 문

다형적 객체를 생성하는 코드 안에서 사용하는 것 이외에는 switch 문은 자제하는 편이 좋다.

switch 문을 추상 팩토리에 숨기고, 팩토리는 switch 문을 사용해 적절한 Employee 파생 클래스의 인스턴스를 생성 

→ 그렇게 되면 calculatePay, isPayday, deliverPay 등과 같은 함수는 Employee 인터페이스를 거쳐 호출 

→ 다형성으로 인해 실제 파생 클래스의 함수가 실행

### 서술적인 이름을 사용하라!

길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.

서술적인 이름을 사용하면 코드를 개선하기 쉬워진다. 또한 모듈 내에서 일관성있게 같은 문구, 명사, 동사를 사용한다.

### 함수 인수

- 많이 쓰는 단항 형식
    - 인수에 질문을 던지는 경우
        - ex) boolean fileExists(”MyFile”)
    - 인수를 변환해 결과를 반환하는 경우
        - ex) InputStream fileOpen(”MyFile”)
- 플래그 인수
    - 함수로 bool 값을 넘기는 건 함수가 한번에 여러가지를 처리하는 것을 공표하는 것이다.
- 이항 함수
    - 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 두 인수 간 자연적인 순서가 없다면 그 순서를 인위적으로 기억해야 한다. 가능하면 단항 함수로 바꾸려고 애써야 한다.
- 삼항 함수
    - 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 삼항 함수를 만들 때는 신중히 고려해야 한다.
- 인수 객체
    - 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언하는 것도 괜찮다. 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표현하게 되기 때문이다.
    
    ```java
    Circle makeCircle(double x, double y, double radius)
    						⬇️  // 좌표 x, y를 Point class로 변경 
    Circle makeCircle(Point center, double radius)
    ```
    
- 인수 목록
    - 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다.
    - String.format 메서드와 같은 경우가 적절한 예로, String.format(”%s worked #.2f hours”, name, hours)의 코드에서 가변 인수를 전부 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다. 이렇게 따지면 String.format은 사실상 이항 함수다.
- 동사와 키워드
    - 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
    - 함수 이름에 인수 이름을 넣으면 인수 순서를 기억할 필요가 없어진다.

### 부수 효과를 일으키지 마라!

부수 효과(Side Effect)는 예상치 못하게 다른 일을 한다. 예상치 못하게 클래스 변수를 수정할 수도 있고, 함수로 넘어온 인수나 시스템 전역 변수를 수정할 수도 있다. 어떤 일이든 temporal coupling이나 order dependency를 초래한다.

- 출력 인수
    - 일반적으로 인수를 함수 입력으로 해석한다. 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. 출력 인수로 사용하라고 설계한 변수가 바로 this이기 때문이다.
    - 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

### 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
- 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나다.

### 오류 코드보다 예외를 사용하라!

명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

→ 오류 코드 대신 try/catch 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리된다.

- try/catch 블록 뽑아내기
    
     try/catch 블록은 정상 동작과 오류 처리 동작이 뒤섞이게 된다. 각 블록을 별도 함수로 뽑아내는 편이 좋다.
    
- 오류 처리도 한 가지 작업이다.
    
    오류를 처리하는 함수는 오류만 처리해야 마땅하다.
    
- Error.java 의존성 자석
    
    오류 코드를 반환한다는 얘기는 어디선가 오류 코드를 정의한다는 뜻이고, 이 Error 클래스를 다른 클래스에서 아주 많이 사용하게 된다. 
    
    ⚠️ 여기서 Error enum이 변한다면? Error enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야 한다. 이건 상당히 번거로운 작업이다.
    
    → 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다. 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.
    

### 반복하지 마라!

중복되는 코드는 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 중복 코드 모두 손봐야 하고, 하나라도 빠뜨릴 확률이 아주 높다.

**중복은 소프트웨어에서 모든 악의 근원이다.** 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다. 

### 구조적 프로그래밍

- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.
- 함수는 return 문이 하나여야 한다. 루프 안에서 break나 continue를 사용해선 안되며 goto는 절대로 안된다.
- 위 규칙은 함수가 아주 클 때만 상당한 이익을 제공한다.

### 함수를 어떻게 짜죠?

소프트웨어를 짜는 행위는 글짓기와 비슷하다. 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다. 이름은 즉흥적이고 코드는 중복된다. 이를 빠짐없이 테스트하는 단위 테스트 케이스를 만든다.

코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다. 처음부터 탁 짜내지 않는다.

```
💡 3장 후기

함수가 하나의 기능만 하도록 하는 다양한 규칙들을 배우며 내가 기존에 생각했던 것보다 함수는 더더욱 작게 쪼개져야 함을 알게 되었다. 이 규칙들을 통해 좀 더 효과적이게 깔끔한 함수를 작성할 수 있을 것 같다. 
여담으로 프로그래밍의 고수가 되면 뭔가 한 번에 좋은 이름과 최적화된 코드를 짤 것 같다고 생각했는데 저자 역시 계속해서 다듬어나가는 과정을 거친다는 점이 의외의 사실이었다. 역시 전문가 정신의 본질은 지속적인 개선이다.
```